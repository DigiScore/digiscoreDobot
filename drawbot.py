# from random import getrandbits, randrange
# from time import time, sleep
# import logging
#
#
#
# ######################
# # DRAWBOT CONTROLS
# ######################
#
# def rnd(self, power_of_command: int) -> int:
#     """Returns a randomly generated + or - integer,
#     influenced by the incoming power factor"""
#     pos = 1
#     if getrandbits(1):
#         pos = -1
#     result = (randrange(1, 5) + randrange(power_of_command)) * pos
#     logging.debug(f'Rnd result = {result}')
#     return result
#
#
# def move_y(self):
#     """When called moves the pen across the y-axis
#     aligned to the delta change in time across the duration of the piece"""
#     # How far into the piece
#     elapsed = time() - self.start_time
#
#     # get current y-value
#     (x, y, z, r, j1, j2, j3, j4) = self.digibot.pose()
#     # NewValue = (((OldValue - OldMin) * (NewMax - NewMin)) / (OldMax - OldMin)) + NewMin
#     newy = (((elapsed - 0) * (175 - -175)) / (self.duration_of_piece - 0)) + -175
#     logging.debug(f'x:{x} y:{y} z:{z} j1:{j1} j2:{j2} j3:{j3} j4:{j4}')
#
#     # check x-axis is in range
#     if x <= 200 or x >= 300:
#         x = 250
#
#     # move z (pen head) a little
#     if getrandbits(1):
#         z = 0
#     else:
#         z = randrange(-2, 2)
#
#     # which mode
#     if self.continuous_line:
#         self.digibot.move_to(x, newy, z, r, True)
#     else:
#         self.digibot.jump_to(x, newy, z, r, True)
#
#     logging.info(f'Move Y to x:{round(x)} y:{round(newy)} z:{round(z)}')
#
#
# def move_y_random(self):
#     """Moves x and y pen position to nearly the true Y point."""
#     # How far into the piece
#     elapsed = time() - self.start_time
#
#     # get current y-value
#     (x, y, z, r, j1, j2, j3, j4) = self.digibot.pose()
#     # NewValue = (((OldValue - OldMin) * (NewMax - NewMin)) / (OldMax - OldMin)) + NewMin
#     newy = (((elapsed - 0) * (175 - -175)) / (self.duration_of_piece - 0)) + -175
#     logging.debug(f'x:{x} y:{y} z:{z} j1:{j1} j2:{j2} j3:{j3} j4:{j4}')
#
#     # check x-axis is in range
#     if x <= 200 or x >= 300:
#         x = 250
#
#     # which mode
#     if self.continuous_line:
#         self.digibot.move_to(x + self.rnd(10), newy + self.rnd(10), 0, r, True)
#     else:
#         self.digibot.jump_to(x + self.rnd(10), newy + self.rnd(10), 0, r, True)
#
#
# def dobot_control(self):
#     """Loop thread that controls the robot arm
#     responses to the data generated by Nebula."""
#
#     print("Started dobot control thread")
#
#     while self.running:
#         while not self.dobot_commands_queue.empty():
#             print('================')
#             # check end of duration
#             if time() > self.end_time:
#                 self.terminate()
#                 self.running = False
#                 break
#
#             # get current nebula emission value
#             # live_emission_data = self.nebula.user_live_emission_data()
#             live_emission_data = self.dobot_commands_queue.get()
#
#             # if the value has changed then ...
#             if live_emission_data != self.old_value:
#                 self.old_value = live_emission_data
#
#                 # multiply by 10 for local logic (power value)
#                 incoming_command = int(live_emission_data * 10) + 10
#                 logging.info(f"MAIN: emission value = {live_emission_data} == {incoming_command}")
#
#                 # 1. clear the alarms
#                 self.digibot.clear_alarms()
#
#                 # 2. move Y
#                 # self.move_y()
#
#                 # 3. get speed based on power of incoming value * global speed setting * 2
#                 if getrandbits(1):
#                     self.digibot.speed(velocity=((incoming_command * 10) * self.global_speed) * 2,
#                                        acceleration=((incoming_command * 10) * self.global_speed) * 2
#                                        )
#                 else:
#                     self.digibot.speed(velocity=randrange(30, 200),
#                                        acceleration=randrange(30, 200)
#                                        )
#
#                 (x, y, z, r, j1, j2, j3, j4) = self.digibot.pose()
#                 logging.debug(f'Current position: x:{x} y:{y} z:{z} j1:{j1} j2:{j2} j3:{j3} j4:{j4}')
#
#                 #
#                 # LOW power response from AI Factory
#                 #
#                 if incoming_command < 3:
#                     # self.move_y()
#                     # self.digibot.dot()
#
#                     logging.info('Emission < 3: PASS')
#
#                 #
#                 # HIGH power response from AI Factory
#                 #
#                 elif incoming_command >= 8:
#                     # self.move_y_random()
#
#                     # does this or that
#                     if getrandbits(1):
#                         self.move_y_random()
#                         logging.info('Emission >= 8: move Y random')
#                     else:
#                         # self.move_y()
#                         self.digibot.arc(x + self.rnd(incoming_command),
#                                          y + self.rnd(incoming_command),
#                                          z, 0,
#                                          x + self.rnd(incoming_command),
#                                          y + self.rnd(incoming_command),
#                                          z, 0,
#                                          False)
#                         logging.info('Emission >= 8: arc')
#
#                 #
#                 # MID power response
#                 #
#                 else:
#                     # randomly choose from the following c hoices
#                     randchoice = randrange(6)
#                     logging.debug(f'randchoice == {randchoice}')
#
#                     # 0= line to somewhere
#                     if randchoice == 0:
#                         self.digibot.move_to(x + self.rnd(incoming_command),
#                                              y + self.rnd(incoming_command),
#                                              z, 0,
#                                              False)
#                         logging.info('Emission 3-8: draw line')
#
#                     # 1 = messy squiggles
#                     if randchoice == 1:
#                         squiggle_list = []
#                         for n in range(randrange(2, 4)):
#                             squiggle_list.append((randrange(-5, 5) / 10,
#                                                   randrange(-5, 5) / 10,
#                                                   randrange(-5, 5) / 10)
#                                                  )
#                         self.digibot.squiggle(squiggle_list)
#                         logging.info('Emission 3-8: small squiggle')
#
#                     # 2 = dot
#                     elif randchoice == 2:
#                         self.digibot.dot()
#                         logging.info('Emission 3-8: dot')
#
#                     # 3 = note head
#                     elif randchoice == 3:
#                         note_size = randrange(5)
#                         note_shape = randrange(20)
#                         self.digibot.note_head(size=note_size,
#                                                steps=note_shape)
#                         logging.info('Emission 3-8: note head')
#
#                     # 4 = note head and line
#                     elif randchoice == 4:
#                         note_size = randrange(5)
#                         note_shape = randrange(20)
#                         self.digibot.note_head(size=note_size,
#                                                steps=note_shape)
#                         self.digibot.move_to(x + self.rnd(incoming_command),
#                                              y + self.rnd(incoming_command),
#                                              z, 0,
#                                              False)
#                         logging.info('Emission 3-8: note head and line')
#
#                     # 5 = dot and random Y
#                     elif randchoice == 5:
#                         self.digibot.dot()
#                         self.move_y_random()
#                         logging.info('Emission 3-8: dot and line')
#
#                 # take a breath
#                 sleep(self.global_speed)
#
#             # wait a bit until the new emission is different from current
#             # self.move_y()
#             sleep(self.global_speed)
#
#     logging.info('quitting dobot director thread')
